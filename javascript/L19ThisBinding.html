<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>함수가 호출하는 this를 찾아보자</title>
</head>
<body>
    <h1>함수가 호출하는 this를 찾아보자(this binding)</h1>
    <p id="pElement">this는 (생성자)함수 function을 호출하는 객체</p>
    <hr>
    <p id="clockEx"></p>
    <script>
       //script를 실행하는 객체: 브라우저(window)
       function a(){
           console.log("나는 함수 a입니다,",this)
       }
       a();//window.a()
       // console.log(pElement)
       pElement.onclick=a
       //pElement에 마우스 클릭시 a가 실행
       //이벤트인 온클릭을 a함수로 재정의했다..(콜백함수)

        //function 함수가 this를 어떻게 binding 하는가? ()=>{} 사용 X
       function User(name,age){
           this.name=name;
           this.age=age;
           this.info=function(){
               console.log(`나는 ${this.name}(${this.age})입니다`);
           }
       }
       let user = new User("범준이형",25);
       console.log(user)
       user.info();

       //js는 함수형언어기 때문에 함수만 따로 참조 가능
       let userInfo = user.info;
       userInfo();
       user={name:"정호",age:19,info:userInfo};
       user.info();

       //비동기함수
       //window.setInterval(function(){},밀리초)
       //setInterval : 콜백함수를 밀리초주기로 반복실행
       //window.setTimeout(function(){},밀리초)
       //setTimeout : 콜백함수를 밀리초 뒤에 실행

       //alert : 경고
       // setTimeout(function (){
       //     alert("warning")
       // },2000)
       setInterval(function (){
           // console.log(Date.now());
           // console.log(new Date());
           clockEx.innerText=new Date();
       },1000);

       let obj = {
           a:10,
           b:20,
           increment: function (){
               // this.a++;
               window.setTimeout(function (){
                   this.a++;//this==window
                   console.log(this.a);
               },2000)
           }

       }

       obj.increment();
       console.log(obj);

        // Function.bind(객체), call(객체)
       //this를 객체로 고정
       //bind : this를 객체로하는 새로운 함수를 반환한다.
       //call: 실행하는 순간에 this를 객체로 바꿈(콜백함수에 적합하지 않다)












    </script>
</body>
</html>